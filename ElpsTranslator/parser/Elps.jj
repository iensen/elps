/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Elps.jj */
/*@egen*///TODO: change extendedNonRelAtom to extendedAtom.
options{  BUILD_PARSER = true;  STATIC = false;  OUTPUT_DIRECTORY = "/home/iensen/elps/ElpsTranslator/parser";               }PARSER_BEGIN(ElpsTranslator)package parser;import java.io.*;import sorts.*;import java.util.HashMap;import java.util.ArrayList;import java.util.List;import java.util.HashSet;import java.util.Scanner;import java.util.Arrays;import java.util.Set;import translating.Translator;import typechecking.TypeChecker;import translating.InstanceGenerator;import configuration.ASPSolver;import externaltools.ClingoSolver;import externaltools.DLVSolver;import externaltools.ExternalSolver;import configuration.Settings;class Pair{  SimpleNode first;  boolean second;  public Pair(SimpleNode first, boolean second)  {    this.first = first;    this.second = second;  }}@ SuppressWarnings("all") public class ElpsTranslator/*@bgen(jjtree)*/implements ElpsTranslatorTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTElpsTranslatorState jjtree = new JJTElpsTranslatorState();

/*@egen*/  // mapping from sort names to sort expressions assigned to the sorts
  public HashMap < String, ASTsortExpression > sortNameToExpression;  // mapping from predicate names to a list of names of sorts describing
  // arguments
  public HashMap < String, ArrayList < String >> predicateArgumentSorts;  // labels of cr-rules
  public HashSet < String > crRuleLabels;  //sort occurred explicitly in the program
  public HashSet < String > generatingSorts;  // mapping from constant names to their values.
  public HashMap < String, Long > constantsMapping;  // warnings found during the translation
  private ArrayList < String > warnings;  // set of all terms occurring in curly brackets and their subterms
  public HashSet < String > curlyBracketTerms;  // set of all defined record names:
  public HashSet < String > definedRecordNames;  boolean inHead = false;
  int anonSortId = 0;  /**
  * Remove from args all 
  */  private static HashSet < String > fetchOptions(String [] args)  {    HashSet < String > options = new HashSet < String > ();    for (int i = 0; i < args.length; i++)    {      if (args [i].startsWith("--"))      {        options.add(args [i]);        args = ArrayUtils.removeNthElement(args, i);        i--;      }    }    return options;  }public static String createOutputFile(String inputFile)
{
    return inputFile+".elp";
}
  public static void main(String [] args)
  {
    System.err.println("ELPS V1.04");
    if(args.length<1)
    {
      System.err.println("a path to an ELPS program must be the only argument");
      return;
    }
    String inputFile = args[0];
    String outputFile = createOutputFile(inputFile);
    Writer out = null;
      Settings.getSingletonInstance().setSolver(ASPSolver.Clingo);
 //   if (new File(outputFile).exists() && !new File(outputFile).isDirectory())
    //  {
   //     System.err.println("the output file already exists , do you want to overwrite it? y/n:");
     //   char rep;
       // try
        //{
         // InputStreamReader converter = new InputStreamReader(System.in);
         // BufferedReader in = new BufferedReader(converter);
          //rep =in.readLine().charAt(0);
        //}
        //catch (IOException e)
        //{
        //e.printStackTrace();
         //return;
        //}
        //if (rep != 'y' && rep != 'Y')
        //{
        // return;
        //}
      //}
      try
      {
        out = new FileWriter(outputFile);
      }
    catch (IOException e)
    {
       e.printStackTrace();
    }
    
    TypeChecker tc = null;
    StringBuilder translatedProgram = new StringBuilder();
    Reader sr = null;
     try
     {
        sr = new FileReader(inputFile);
     }
      catch (FileNotFoundException fileException)
      {
          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());
          return;
      }
      
      ElpsTranslator p = new ElpsTranslator(sr);
      try
      {
        
      SimpleNode e = p.program();
      //process regular expression
      InstanceGenerator gen = new InstanceGenerator(p.sortNameToExpression);
      tc = new TypeChecker(p.sortNameToExpression, p.predicateArgumentSorts, p.constantsMapping, p.curlyBracketTerms, p.definedRecordNames, gen);
      Translator tr = new Translator(out, p, gen, false, false);
      // do typechecking of rules in the first file
      String fileName=getShortFileName(inputFile);
      tr.setInputFileName(fileName);
      tc.setInputFileName(fileName);
            
      if(e.jjtGetNumChildren() >2)//if program is not empty
      {
        tc.checkRules((ASTprogramRules) e.jjtGetChild(2));
        translatedProgram.append(tr.translateProgram((ASTprogram) e, p.generatingSorts, true));
      }
      tr.writeTranslatedProgram();
      System.err.println("program translated");
      AnswerSetParser aParser = new ClingoAnswerSetParser();
      ExternalSolver solver = null;
      try      {   
        solver = new ClingoSolver(translatedProgram.toString());
      }
      catch(Exception ex)      {         System.err.println(ex.getMessage());
      }
      ArrayList<AnswerSet > answerSets = aParser.getAnswerSets(solver.run(true));
      WorldViewExtractor we = new WorldViewExtractor();
      ArrayList<ArrayList<AnswerSet>> worldViews = we.extractWorldViews(answerSets);
      printWorldViews(worldViews);
      
    }
    catch (ParseException pe)
    {
      System.err.println(pe.getMessage());
      return;
    }
 
    
  }

  private static void printWorldViews(ArrayList<ArrayList<AnswerSet >> worldViews)  {
         for (int i = 0 ;i<worldViews.size();i++)     {
       System.out.println("World View " +(i+1) + " out of " + worldViews.size());
       System.out.print("{");       boolean firstAnswerSet = true;
       int aSet = 1;
       for(AnswerSet answerSet : worldViews.get(i))       {
         System.out.println("Answer Set " + aSet+ ": ");
        //  if(!firstAnswerSet)
         //      System.out.print(", ");
          firstAnswerSet = false;          System.out.print("{");
          boolean firstAtom = true;
          for(String atom : answerSet.atoms)          {
             if(!firstAtom)             {
               System.out.print(", ");             }
             firstAtom = false;
             System.out.print(atom);          }
          System.out.print("}");
          System.out.println("\n\n");
            ++ aSet;
       }
        System.out.println("}"+ "\n");
                 }
  }   private boolean isInteger(String s)  {
    if(s.length()< 1)
              return false;    if (s.length() == 1 && s.charAt(0) == '0') return true;    if (s.charAt(0) == '0') return false;    for (int i = 0; i < s.length(); i++)    {      if (!Character.isDigit(s.charAt(i))) return false;    }    return true;  }  /**
  * @return absolute path.
  */  private static String getShortFileName(String fullPath)  {    File file = new File(fullPath);    return file.getName();  }  static final String newLine = System.getProperty("line.separator");  /**
  * Output help message
  */  private static void show_usage()  {    System.err.println("usage: elps filename ");  }  /**
  * Add built-in sorts to sort expressions
  */  public void addBuiltInSorts()  {    HashMap < String, ASTsortExpression > builtInSorts = BuiltIn.getBuiltInSorts();    for (String sortName : builtInSorts.keySet())    {      sortNameToExpression.put(sortName, builtInSorts.get(sortName));    }  }  /**
  * Add warning to set of warnings
  */  public void addWarning(String warning)  {    warnings.add(warning);  }  public ArrayList < String > getWarnings()  {    return warnings;  }}PARSER_END(ElpsTranslator)< DEFAULT, IN_PROGRAM_RULES >TOKEN :{  < MAXINTDIRECTIVE : "#maxint" >| < CONSTDIRECTIVE : "#const" >| < SORTDEFKEYWORD : "sorts" ([ "\r", "\t", " ", "\n" ])+ >| < PREDDEFKEYWORD : "predicates" ([ "\r", "\t", " ", "\n" ])+ >| < PROGRULDEFKEYWORD : "rules" ([ "\r", "\t", " ", "\n" ])+ > : IN_PROGRAM_RULES| < NOT : "not" ([ "\t", "\r", " " ])+ >| < NOTOP : "not" ([ "\t", "\r", " " ])* "(" >| < OR : "or" >| < AND : "and" >| < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
| < KIDENTIFIER : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )? [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >| < VARIABLE :    (      [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])*    | "_"    ) >| < NONZERODIGIT : [ "1"-"9" ] >| < POSITIVE_INTEGER :    < NONZERODIGIT >    (      < ZERO >    | < NONZERODIGIT >    )* >| < ZERO : "0" >| < PLUS : "+" >| < MULT : "*" >| < DIV : "/" >| < EQ : "=" >| < EQR : "==" >| < NOTEQ : "!=" >| < GT : ">" >| < GTEQ : ">=" >| < SM : "<" >| < SMEQ : "<=" >| < OP : "(" >| < CP : ")" >| < OB : "{" >| < CB : "}" >| < ORRSEP : ":-" >| < CRRSEP : ":+" >| < WEAKSEP : ":~" >| < COMMA : "," >| < DOT : "." >| < COLON : ":" >| < SEMICOLON : ";" >| < COMPLEMENT : "~" >| < HEAD_OR : "|" >| < AGGREGATE_COUNT_OB : "#count"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_SUM_OB : "#sum"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_MIN_OB : "#min"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_MAX_OB : "#max"([ "\t", "\r", "\n"," " ])* "{" >| < OSB : "[" >| < OCB : "]" >| < POUND_SIGN : "#" >}< IN_PROGRAM_RULES >TOKEN :
{
 < IDENTIFIER_WITH_OP : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )? [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >
|< KIDENTIFIER_WITH_OP : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )? [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >
| < NEGATIVE_ATOM_WITH_OP : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )?"-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >
| < NEGATIVE_SORT_ATOM_WITH_OP : "-#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >
| < NEGATIVE_ATOM : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )?"-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >SKIP :{  < SINGLE_LINE_COMMENT :    "%" (~[ "\n", "\r" ])*    (      "\r"    | "\n"    | "\r\n"    )? >| < SPACE : ([ "\n", "\r", "\t", " " ])+ >}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >TOKEN :{  < MINUS : "-" >}SimpleNode program() :{/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  sortNameToExpression = new HashMap < String, ASTsortExpression > ();  predicateArgumentSorts = new HashMap < String, ArrayList < String >> ();  crRuleLabels = new HashSet < String > ();  generatingSorts = new HashSet < String > ();  constantsMapping = new HashMap < String, Long > ();  warnings = new ArrayList < String > ();  curlyBracketTerms = new HashSet < String > ();  definedRecordNames = new HashSet < String > ();}{/*@bgen(jjtree) program */
  try {
/*@egen*/  directives(jjtn000.directives) sortDefinitions() predicateDeclarations() programRules() < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  } | < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {
    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
  }void sortDefinitions() :{/*@bgen(jjtree) sortDefinitions */
  ASTsortDefinitions jjtn000 = new ASTsortDefinitions(JJTSORTDEFINITIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) sortDefinitions */
  try {
/*@egen*/  (    < SORTDEFKEYWORD >    (      sortDefinition()    )*  )|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void sortDefinition() :{/*@bgen(jjtree) sortDefinition */
  ASTsortDefinition jjtn000 = new ASTsortDefinition(JJTSORTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode n;}{/*@bgen(jjtree) sortDefinition */
  try {
/*@egen*/  < POUND_SIGN > t = < IDENTIFIER > < EQ > n = sortExpression() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (sortNameToExpression.containsKey(t.image))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was already defined");    }    for (String builtInSortName : BuiltIn.sortNames)    {      if (t.image.equals(builtInSortName))      {        throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " is built-in and cannot be redefined");      }    }    if (EmptySortChecker.isEmpty((ASTsortExpression) n, sortNameToExpression))    {      throw new ParseException("sort " + t.image + " defined at line " + t.beginLine + " column " + t.beginColumn + " is empty");    }    sortNameToExpression.put(t.image, (ASTsortExpression) n);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode sortExpression() :{/*@bgen(jjtree) sortExpression */
  ASTsortExpression jjtn000 = new ASTsortExpression(JJTSORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  String s;}{/*@bgen(jjtree) sortExpression */
  try {
/*@egen*/
  LOOKAHEAD(2)  n = setExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })  n = numericRange()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| LOOKAHEAD(identifierRange())  n = identifierRange()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| n = concatenation()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode setExpression() :{/*@bgen(jjtree) setExpression */
  ASTsetExpression jjtn000 = new ASTsetExpression(JJTSETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) setExpression */
  try {
/*@egen*/  n = additiveSetExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode multiplicativeSetExpression() :{/*@bgen(jjtree) multiplicativeSetExpression */
  ASTmultiplicativeSetExpression jjtn000 = new ASTmultiplicativeSetExpression(JJTMULTIPLICATIVESETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) multiplicativeSetExpression */
  try {
/*@egen*/  n = unarySetExpression()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    < MULT > unarySetExpression()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode additiveSetExpression() :{/*@bgen(jjtree) additiveSetExpression */
  ASTadditiveSetExpression jjtn000 = new ASTadditiveSetExpression(JJTADDITIVESETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  jjtn000.image = "+";  SimpleNode n;}{/*@bgen(jjtree) additiveSetExpression */
  try {
/*@egen*/  n = multiplicativeSetExpression()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    (      "+"      {        jjtn000.image += "+";      }    | "-"      {        jjtn000.image += "-";      }    )    multiplicativeSetExpression()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode sortName() :{/*@bgen(jjtree) sortName */
  ASTsortName jjtn000 = new ASTsortName(JJTSORTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) sortName */
  try {
/*@egen*/  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (!sortNameToExpression.containsKey(t.image))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");    }    else    {      jjtn000.image = t.image;      jjtn000.beginLine = t.beginLine;      jjtn000.beginColumn = t.beginColumn;    }    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unarySetExpression() :{/*@bgen(jjtree) unarySetExpression */
  ASTunarySetExpression jjtn000 = new ASTunarySetExpression(JJTUNARYSETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode n;}{/*@bgen(jjtree) unarySetExpression */
  try {
/*@egen*/  t = < POUND_SIGN > sortName()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }| n = curlyBrackets()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| t = < OP > setExpression() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }

  | n = functionalSymbol()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  {
    if (!FunctionalSymbolChecker.checkFunctionalSymbolSorts((ASTfunctionalSymbol) n, sortNameToExpression))
    {
      throw new ParseException("the definition of record " + n.image + " at line " + n.beginLine + " column " + n.beginColumn + " has a condition which involves " + "checking less/greater relations on elements of non-basic sorts");
    }
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode curlyBrackets() :{/*@bgen(jjtree) curlyBrackets */
  ASTcurlyBrackets jjtn000 = new ASTcurlyBrackets(JJTCURLYBRACKETS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode child;}{/*@bgen(jjtree) curlyBrackets */
  try {
/*@egen*/  t = < OB > child = constantTermList() < CB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    CurlyBrackets.retrieveAllTerms((ASTconstantTermList) child, curlyBracketTerms);    CurlyBrackets.retrieveAllFunctionalSymbols(jjtn000, definedRecordNames);    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void concatenationTermList()                   :{/*@bgen(jjtree) constantTermList */
  ASTconstantTermList jjtn000 = new ASTconstantTermList(JJTCONSTANTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) constantTermList */
  try {
/*@egen*/  concatenationTerm()  (    < COMMA > concatenationTerm()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode constantTermList() :{/*@bgen(jjtree) constantTermList */
  ASTconstantTermList jjtn000 = new ASTconstantTermList(JJTCONSTANTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) constantTermList */
  try {
/*@egen*/  constantTerm()  (    < COMMA > constantTerm()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void constantTerm():{/*@bgen(jjtree) constantTerm */
  ASTconstantTerm jjtn000 = new ASTconstantTerm(JJTCONSTANTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2, t3;  String s;}{/*@bgen(jjtree) constantTerm */
  try {
/*@egen*/  LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })  t1 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(2)  t1 = < IDENTIFIER > t3 = < OP > constantTermList() t2 = < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image + t3.image + " " + t2.image;  }| t1 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void concatenationTerm()               :{/*@bgen(jjtree) constantTerm */
  ASTconstantTerm jjtn000 = new ASTconstantTerm(JJTCONSTANTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1;}{/*@bgen(jjtree) constantTerm */
  try {
/*@egen*/  LOOKAHEAD({ constantsMapping.containsKey(getToken(1).image) })  t1 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| t1 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode condition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) condition */
  ASTcondition jjtn000 = new ASTcondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t, t1, t2;}{/*@bgen(jjtree) condition */
  try {
/*@egen*/  orCondition(varMap)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void orCondition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) orCondition */
  ASTorCondition jjtn000 = new ASTorCondition(JJTORCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) orCondition */
  try {
/*@egen*/  andCondition(varMap)  (    < OR > andCondition(varMap)  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void andCondition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) andCondition */
  ASTandCondition jjtn000 = new ASTandCondition(JJTANDCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) andCondition */
  try {
/*@egen*/  unaryCondition(varMap)  (    < AND > unaryCondition(varMap)  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void unaryCondition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) unaryCondition */
  ASTunaryCondition jjtn000 = new ASTunaryCondition(JJTUNARYCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t, t3, t4;}{/*@bgen(jjtree) unaryCondition */
  try {
/*@egen*/  t3 = var()  {    jjtn000.image = varMap.get(t3.image).toString();  }  t = rel()  {    jjtn000.image += " " + t.image;  }  t4 = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image += " " + varMap.get(t4.image).toString();  }| < OP > condition(varMap) < CP >| t = < NOTOP > condition(varMap) < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode functionalSymbol() :{/*@bgen(jjtree) functionalSymbol */
  ASTfunctionalSymbol jjtn000 = new ASTfunctionalSymbol(JJTFUNCTIONALSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2, t3;  Token from, to;  HashMap < String, Integer > map;  HashSet < Integer > BasicSorts;  SimpleNode c = null;}{/*@bgen(jjtree) functionalSymbol */
  try {
/*@egen*/  t1 = < IDENTIFIER > t3 = < OP >  {}  map = specialSortExpressionList() t2 = < CP > [ < COLON > c = condition(map) ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    definedRecordNames.add(t1.image);    jjtn000.beginLine = t1.beginLine;    jjtn000.beginColumn = t1.beginColumn;    jjtn000.image = t1.image + t3.image + t2.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token specialSortExpression()       :{  Token sortToken,t = null;}{  < POUND_SIGN > sortName() [ < OP > t = < VARIABLE > < CP > ]  {    return t;  }}HashMap < String, Integer > specialSortExpressionList()                     :{/*@bgen(jjtree) sortExpressionList */
  ASTsortExpressionList jjtn000 = new ASTsortExpressionList(JJTSORTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  HashMap < String, Integer > variableMapping = new HashMap < String, Integer > ();  int agr = 0;  Token t;}{/*@bgen(jjtree) sortExpressionList */
  try {
/*@egen*/  t = specialSortExpression()  {    if (t != null)    {      if (variableMapping.containsKey(t.image))      {        throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");      }      variableMapping.put(t.image, agr);    }    agr++;  }  (    < COMMA > t = specialSortExpression()    {      if (t != null)      {        if (variableMapping.containsKey(t.image))        {          throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");        }        variableMapping.put(t.image, agr);      }      agr++;    }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return variableMapping;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode concatenation() :{/*@bgen(jjtree) concatenation */
  ASTconcatenation jjtn000 = new ASTconcatenation(JJTCONCATENATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) concatenation */
  try {
/*@egen*/  (    < OSB > basicSort() < OCB >  )+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void basicSort() :{/*@bgen(jjtree) basicSort */
  ASTbasicSort jjtn000 = new ASTbasicSort(JJTBASICSORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode se;  Token t;  String s;}{/*@bgen(jjtree) basicSort */
  try {
/*@egen*/  LOOKAHEAD({ (getToken(1) != null && (s = getToken(1).image) != null) && (constantsMapping.containsKey(s) || isInteger(s)) })  numericRange()| LOOKAHEAD(identifierRange())  identifierRange()| t = < POUND_SIGN > se = sortName()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (!sortNameToExpression.containsKey(se.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");    }    ASTsortExpression ex = sortNameToExpression.get(se.image);    if (!BasicSortChecker.isBasic(ex, sortNameToExpression))    {      throw new ParseException("ERROR: Sort '" + se.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is not a basic sort");    }  }| concatenationTermList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode identifierRange() :{/*@bgen(jjtree) identifierRange */
  ASTidentifierRange jjtn000 = new ASTidentifierRange(JJTIDENTIFIERRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2;}{/*@bgen(jjtree) identifierRange */
  try {
/*@egen*/  t1 = < IDENTIFIER > < DOT > < DOT > t2 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    int errorLine = t1.beginLine;    int errorColumn = t1.beginColumn;    if (t1.image.length() > t2.image.length())    {      throw new ParseException("ERROR: the length of the first identifier in identifier range should be smaller or equal to the length of the second one " + "at line " + errorLine + ", column " + errorColumn);    }    if (t1.image.compareTo(t2.image) > 0)    {      throw new ParseException("ERROR: the first identifier in identifier range should be lexicographically smaller or equal to  the second one " + "at line " + errorLine + ", column " + errorColumn);    }    jjtn000.image = t1.image + " " + t2.image;
    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode numericRange() :{/*@bgen(jjtree) numericRange */
  ASTnumericRange jjtn000 = new ASTnumericRange(JJTNUMERICRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token from, to;}{/*@bgen(jjtree) numericRange */
  try {
/*@egen*/  from = number()  {    jjtn000.beginLine = from.beginLine;    jjtn000.beginColumn = from.beginColumn;  }  < DOT > < DOT > to = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    int fromI = 0;    int toI = 0;    try    {      fromI = Integer.parseInt(from.image);      toI = Integer.parseInt(to.image);    }    catch (NumberFormatException ex)    {}    if (fromI > toI)    {      throw new ParseException("ERROR: the first number in numeric  range should be smaller or equal to  the second one " + "at line " + to.beginLine + ", column " + to.beginColumn);    }    jjtn000.image = from.image + " " + to.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token number()       :{  Token t;}{  t = < POSITIVE_INTEGER >  {
    int integer = Integer.parseInt(t.image);
	if(integer >  BuiltIn.getMaxInt() )	{	    throw new ParseException("ERROR: Integer '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is out of range");
    }    return t;  }| t = < ZERO >  {    return t;  }| t = < NONZERODIGIT >  {    return t;  }| t = < IDENTIFIER >  {    if (!constantsMapping.containsKey(t.image))    {      throw new ParseException("ERROR: Constant '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " was not defined");      //return t;
    }    else    {      t.image = constantsMapping.get(t.image).toString();      return t;    }  }}void predicateDeclarations() :{/*@bgen(jjtree) predicateDeclarations */
  ASTpredicateDeclarations jjtn000 = new ASTpredicateDeclarations(JJTPREDICATEDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) predicateDeclarations */
  try {
/*@egen*/  < PREDDEFKEYWORD >  (    predicateDeclaration()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    HashSet < String > usedPredicateNames = new HashSet < String > ();    usedPredicateNames.addAll(predicateArgumentSorts.keySet());
    HashMap<String,String > sortRenaming=new HashMap<String,String >();    for (String sortName : sortNameToExpression.keySet())    {      predicateArgumentSorts.put("#" + sortName, new ArrayList < String > ());      String nameCandidate = sortName;      while (usedPredicateNames.contains(nameCandidate))      {        nameCandidate += "_";      }      usedPredicateNames.add(nameCandidate);      predicateArgumentSorts.get("#" + sortName).add(nameCandidate);
      if(!sortName.equals(nameCandidate))      {
        //update all sort names from predicate lists:
        sortRenaming.put(sortName,nameCandidate);
        for(String predicateName:predicateArgumentSorts.keySet())        {           ArrayList<String > arguments= predicateArgumentSorts.get(predicateName);
           for(int i=0;i<arguments.size();i++)           {               if(arguments.get(i).equals(sortName))               {
                 arguments.set(i,nameCandidate);               }
           }
        }

        // update all sort names in functional symbol definitions!!!

        for(String sortName1:sortNameToExpression.keySet())        {
          ASTsortExpression se= sortNameToExpression.get(sortName1);
          SimpleNode child = (SimpleNode)se.jjtGetChild(0);
          if(child.getId() == ElpsTranslatorTreeConstants.JJTSETEXPRESSION)          {
            SimpleNode additiveSetExpr = (SimpleNode) child.jjtGetChild(0);
            for(int i=0;i<additiveSetExpr.jjtGetNumChildren();i++)            {
              SimpleNode multiplicativeSetExpr = (SimpleNode) additiveSetExpr.jjtGetChild(i);
              for(int j=0;j<multiplicativeSetExpr.jjtGetNumChildren();j++)              {                   SimpleNode unarySortExpr = (SimpleNode) multiplicativeSetExpr.jjtGetChild(j);
                   child = (SimpleNode)unarySortExpr.jjtGetChild(0);
                   if(child.getId() == ElpsTranslatorTreeConstants.JJTFUNCTIONALSYMBOL)
                   {
                       ASTsortExpressionList sortNameList = (ASTsortExpressionList)child.jjtGetChild(0);
                       for(int k=0;k<sortNameList.jjtGetNumChildren();k++)
                       {           
                            ASTsortName oldSortName = (ASTsortName)sortNameList.jjtGetChild(k);
                            if(oldSortName.image.equals(sortName))                            {
                                oldSortName.image = sortRenaming.get(oldSortName.image);                            }                          
                       }
                  }
              }            }              }        }      }    }
    for(String sortName:sortRenaming.keySet())    {
        sortNameToExpression.put(sortRenaming.get(sortName),sortNameToExpression.get(sortName));
        sortNameToExpression.remove(sortName);    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void predicateDeclaration() :{/*@bgen(jjtree) predicateDeclaration */
  ASTpredicateDeclaration jjtn000 = new ASTpredicateDeclaration(JJTPREDICATEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  ArrayList < String > arguments = new ArrayList < String > ();}{/*@bgen(jjtree) predicateDeclaration */
  try {
/*@egen*/  t = < IDENTIFIER >  {    if (predicateArgumentSorts.containsKey(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " was already declared");    }    if (BuiltInPredicates.predicateNamesSet.contains(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " is a built-in predicate");    }  }  < OP >  (    arguments = identifierList()  )?  {    predicateArgumentSorts.put(t.image, arguments);  }  < CP > < DOT >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}ArrayList < String > identifierList() :{/*@bgen(jjtree) identifierList */
  ASTidentifierList jjtn000 = new ASTidentifierList(JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  ArrayList < String > result = new ArrayList < String > ();  Token t;}{/*@bgen(jjtree) identifierList */
  try {
/*@egen*/
    (    < POUND_SIGN > t = < IDENTIFIER >  {    if (!sortNameToExpression.containsKey(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");    }    result.add(t.image);  }  (    < COMMA > < POUND_SIGN > t = < IDENTIFIER >    {
     if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");
    }      result.add(t.image);    }  )*)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return result;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode programRules() :{/*@bgen(jjtree) programRules */
  ASTprogramRules jjtn000 = new ASTprogramRules(JJTPROGRAMRULES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) programRules */
  try {
/*@egen*/  < PROGRULDEFKEYWORD >  (    programRule()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode programRule() :{/*@bgen(jjtree) programRule */
  ASTprogramRule jjtn000 = new ASTprogramRule(JJTPROGRAMRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode n;  inHead = true;}{/*@bgen(jjtree) programRule */
  try {
/*@egen*/  LOOKAHEAD(2)  t = label()  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    jjtn000.setLabel(t.image);    if (crRuleLabels.contains(t.image))    {      throw new ParseException("cr-rule label " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " occures more then once");    }    else    {      crRuleLabels.add(t.image);    }  }  n = unlabeledProgramCrRule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| n = unlabeledProgramRule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unlabeledProgramRule() :{/*@bgen(jjtree) unlabeledProgramRule */
  ASTunlabeledProgramRule jjtn000 = new ASTunlabeledProgramRule(JJTUNLABELEDPROGRAMRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Pair n;  SimpleNode n2;  Token from, to, sep;}{/*@bgen(jjtree) unlabeledProgramRule */
  try {
/*@egen*/  LOOKAHEAD(predSymbol() number() < DOT >)  n = predSymbol() from = number() < DOT > < DOT > to = number() < CP > < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ //can be body here after safety fix!
  {    jjtn000.beginLine = n.first.beginLine;    jjtn000.beginColumn = n.first.beginColumn;    jjtn000.image = n.first.image + " " + from.image + " " + to.image;    inHead = false;    return jjtn000;  }| n2 = head()  {    inHead = false;  }  sep = exBody()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = sep.image;    jjtn000.beginLine = n2.beginLine;    jjtn000.beginColumn = n2.beginColumn;    return jjtn000;  }| sep = < ORRSEP >  {    inHead = false;    jjtn000.image = sep.image;    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;  }  body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }| sep = < CRRSEP >  {    inHead = false;    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;    jjtn000.image = sep.image;  }  body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }| sep = < WEAKSEP >  {    inHead = false;    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;    jjtn000.image = sep.image;  }  body() < DOT > [ constraintParams() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void constraintParams() :{/*@bgen(jjtree) constraintParams */
  ASTconstraintParams jjtn000 = new ASTconstraintParams(JJTCONSTRAINTPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t0;  Token t1 = null, t2 = null, t3 = null, t4 = null, t5 = null;  jjtn000.image = "";}{/*@bgen(jjtree) constraintParams */
  try {
/*@egen*/  t0 = < OSB >  [    (      t1 = var()    | t2 = number()    )  ]  t5 = < COLON >  [    (      t3 = var()    | t4 = number()    )  ]  < OCB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (t1 == null && t2 == null && t3 == null && t4 == null)    {      throw new ParseException("line " + t0.beginLine + ", column " + t0.beginColumn + ": weak constraint paramethers cannot both be empty");    }    if (t2 != null)    {      jjtn000.image += t2.image;    }    else if (t1 != null)    {      jjtn000.image += "V";    }    jjtn000.image += t5.image;    if (t4 != null)    {      jjtn000.image += t4.image;    }    else if (t3 != null)    {      jjtn000.image += "V";    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unlabeledProgramCrRule() :{/*@bgen(jjtree) unlabeledProgramCrRule */
  ASTunlabeledProgramCrRule jjtn000 = new ASTunlabeledProgramCrRule(JJTUNLABELEDPROGRAMCRRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t;}{/*@bgen(jjtree) unlabeledProgramCrRule */
  try {
/*@egen*/  n = head() t = exCrBody()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    jjtn000.image = t.image;    return jjtn000;  }| t = < CRRSEP > body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    jjtn000.image = t.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token label()       :{  Token t;}{  t = < IDENTIFIER > < COLON >  {    return t;  }}Token exBody()       :{  Token t;}{  t = exStandartBody()  {    return t;  }| t = exCrBody()  {    return t;  }}Token exStandartBody()       :{  Token t;}{  t = < ORRSEP > body() < DOT >  {    return t;  }| t = < DOT >  {    return new Token(ElpsTranslatorConstants.ORRSEP, ":-");  }}Token exCrBody()       :{  Token t;}{  t = < CRRSEP > crBodyWithoutSep()  {    return t;  }}void crBodyWithoutSep()       :{}{  < DOT >| body() < DOT >}SimpleNode head() :{/*@bgen(jjtree) head */
  ASThead jjtn000 = new ASThead(JJTHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) head */
  try {
/*@egen*/  LOOKAHEAD(2)  n = choice_rule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| n = disjunction()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode disjunction() :{/*@bgen(jjtree) disjunction */
  ASTdisjunction jjtn000 = new ASTdisjunction(JJTDISJUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) disjunction */
  try {
/*@egen*/  n = nonRelAtom()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    < HEAD_OR > nonRelAtom()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode choice_rule() :{/*@bgen(jjtree) choice_rule */
  ASTchoice_rule jjtn000 = new ASTchoice_rule(JJTCHOICE_RULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n1 = null;  Token t;}{/*@bgen(jjtree) choice_rule */
  try {
/*@egen*/  [    n1 = arithmeticTerm()    [      t = rel()      {        jjtn000.image = "L" + t.image;      }    ]  ]  t = < OB > choice_elements() < CB >  [    [      t = rel()      {        jjtn000.image += " R" + t.image;      }    ]    arithmeticTerm()  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (n1 != null)    {      jjtn000.beginLine = n1.beginLine;      jjtn000.beginColumn = n1.beginColumn;    }    else    {      jjtn000.beginLine = t.beginLine;      jjtn000.beginColumn = t.beginColumn;    }    if (Settings.getSingletonInstance().getSolver() != ASPSolver.Clingo)     throw new ParseException("line " + jjtn000.beginLine + ", column " + jjtn000.beginColumn + ": choice rules are not supported in DLV");    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void choice_elements() :{/*@bgen(jjtree) choice_elements */
  ASTchoice_elements jjtn000 = new ASTchoice_elements(JJTCHOICE_ELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) choice_elements */
  try {
/*@egen*/  choice_element()  (    < SEMICOLON > choice_element()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void choice_element() :{/*@bgen(jjtree) choice_element */
  ASTchoice_element jjtn000 = new ASTchoice_element(JJTCHOICE_ELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) choice_element */
  try {
/*@egen*/  n = nonRelAtom() [ < COLON > extendedSimpleAtomList() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void extendedSimpleAtomList() :{/*@bgen(jjtree) extendedSimpleAtomList */
  ASTextendedSimpleAtomList jjtn000 = new ASTextendedSimpleAtomList(JJTEXTENDEDSIMPLEATOMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) extendedSimpleAtomList */
  try {
/*@egen*/  simpleAtom()  (    < COMMA > simpleAtom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void body() :{/*@bgen(jjtree) body */
  ASTbody jjtn000 = new ASTbody(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) body */
  try {
/*@egen*/  atom()  (    < COMMA > atom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token var() :{/*@bgen(jjtree) var */
  ASTvar jjtn000 = new ASTvar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) var */
  try {
/*@egen*/  t = < VARIABLE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.setOriginalImage(t.image);    return t;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode nonRelAtom():{/*@bgen(jjtree) nonRelAtom */
  ASTnonRelAtom jjtn000 = new ASTnonRelAtom(JJTNONRELATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode tList = null;  Pair n;}{/*@bgen(jjtree) nonRelAtom */
  try {
/*@egen*/  n = predSymbol()  {    jjtn000.beginLine = n.first.beginLine;    jjtn000.beginColumn = n.first.beginColumn;
    String disallowedPrefixes[] = {"k_","m_","k_0","m_0","k1_0","k0_0",
				                   "k1_","k0_","m1_0","m1_","m0_0","m0_"};
    for(String prefix: disallowedPrefixes)    {        if(n.first.image.startsWith(prefix))        {
             throw new ParseException("ERROR: predicate names starting from "+ prefix +" are not allowed; line " + n.first.beginLine + " column " + n.first.beginColumn);        }
    }

    ASTpredSymbol predS1 = (ASTpredSymbol) n.first;
    if(predS1.subj!=0)
    {
        throw new ParseException("ERROR: subjective literals are only allowed in the bodies of rules; line " + n.first.beginLine + " column " + n.first.beginColumn);
    }  }  [    tList = termList()    {      if (!n.second && tList != null)      {        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);      }    }    < CP >  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    ASTpredSymbol predS = (ASTpredSymbol) n.first;    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1))    {      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");    }    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void simpleAtom() :{/*@bgen(jjtree) simpleAtom */
  ASTsimpleAtom jjtn000 = new ASTsimpleAtom(JJTSIMPLEATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t;}{/*@bgen(jjtree) simpleAtom */
  try {
/*@egen*/  LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() t = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() t = rel() var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() t = rel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(var() rel() symbolicTerm())  var() t = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() t = eqrel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() t = eqrel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| n = extendedNonRelAtom()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = n.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode extendedNonRelAtom() :{/*@bgen(jjtree) extendedNonRelAtom */
  ASTextendedNonRelAtom jjtn000 = new ASTextendedNonRelAtom(JJTEXTENDEDNONRELATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t = null;  jjtn000.image = "";  SimpleNode tList = null;  Pair n;}{/*@bgen(jjtree) extendedNonRelAtom */
  try {
/*@egen*/  [    t = < NOT >    {      jjtn000.image = t.image;    }  ]  n = predSymbol(){
    ASTpredSymbol predS1 = (ASTpredSymbol) n.first;
    if(n.first.image.startsWith("k_") || n.first.image.startsWith("m_"))
    {
        throw new ParseException("ERROR: predicate names starting from k_ or m_ are not allowed; line " + n.first.beginLine + " column " + n.first.beginColumn);
    }

    if(t!=null && (predS1.subj!=0))
    {
        System.out.println(predS1.negatedSubj);
        throw new ParseException("ERROR: not is not allowed before subjective literals " + n.first.beginLine + " column " + n.first.beginColumn);
    }
  }
    [    tList = termList()    {      if (!n.second && tList != null)      {        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);      }    }    < CP >  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    ASTpredSymbol predS = (ASTpredSymbol) n.first;    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1))    {      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");    }    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode addOp()      :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < PLUS >  {    n.image = t.image;    return n;  }| t = < MINUS >  {    n.image = t.image;    return n;  }}SimpleNode multOp()       :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < MULT >  {    n.image = t.image;    return n;  }| t = < DIV >  {    n.image = t.image;    return n;  }}SimpleNode arithmeticTerm() :{/*@bgen(jjtree) arithmeticTerm */
  ASTarithmeticTerm jjtn000 = new ASTarithmeticTerm(JJTARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) arithmeticTerm */
  try {
/*@egen*/  n = additiveArithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode atomicArithmeticTerm() :{/*@bgen(jjtree) atomicArithmeticTerm */
  ASTatomicArithmeticTerm jjtn000 = new ASTatomicArithmeticTerm(JJTATOMICARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;
 }{/*@bgen(jjtree) atomicArithmeticTerm */
  try {
/*@egen*/
  
  LOOKAHEAD({  (getToken(1) != null && getToken(1).image != null) && (constantsMapping.containsKey(getToken(1).image ) || isInteger(getToken(1).image )) })  t = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }| t = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }| t = < OP > arithmeticTerm() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode additiveArithmeticTerm() :{/*@bgen(jjtree) additiveArithmeticTerm */
  ASTadditiveArithmeticTerm jjtn000 = new ASTadditiveArithmeticTerm(JJTADDITIVEARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  jjtn000.image = "+";}{/*@bgen(jjtree) additiveArithmeticTerm */
  try {
/*@egen*/  n = multiplicativeArithmeticTerm()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    n = addOp()    {      jjtn000.image += n.image;    }    multiplicativeArithmeticTerm()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode multiplicativeArithmeticTerm() :{/*@bgen(jjtree) multiplicativeArithmeticTerm */
  ASTmultiplicativeArithmeticTerm jjtn000 = new ASTmultiplicativeArithmeticTerm(JJTMULTIPLICATIVEARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  jjtn000.image = "";}{/*@bgen(jjtree) multiplicativeArithmeticTerm */
  try {
/*@egen*/  n = atomicArithmeticTerm()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    n = multOp()    {      jjtn000.image += n.image;    }    atomicArithmeticTerm()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode symbolicFunction() :{/*@bgen(jjtree) symbolicFunction */
  ASTsymbolicFunction jjtn000 = new ASTsymbolicFunction(JJTSYMBOLICFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) symbolicFunction */
  try {
/*@egen*/  t = < IDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginColumn = t.beginColumn;    jjtn000.beginLine = t.beginLine;    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
SimpleNode symbolicConstant() :
{/*@bgen(jjtree) symbolicConstant */
  ASTsymbolicConstant jjtn000 = new ASTsymbolicConstant(JJTSYMBOLICCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) symbolicConstant */
  try {
/*@egen*/
  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}SimpleNode symbolicTerm() :{/*@bgen(jjtree) symbolicTerm */
  ASTsymbolicTerm jjtn000 = new ASTsymbolicTerm(JJTSYMBOLICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) symbolicTerm */
  try {
/*@egen*/  n = symbolicConstant()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| n = symbolicFunction()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  termList() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode term() :{/*@bgen(jjtree) term */
  ASTterm jjtn000 = new ASTterm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t;  jjtn000.image = "";}{/*@bgen(jjtree) term */
 try {
/*@egen*/ LOOKAHEAD(var() (< CP >| < COMMA >))  t = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    //System.out.println("t.image");
    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }
| 
  LOOKAHEAD(2)
  n = arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }| n = symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/}SimpleNode termList() :{/*@bgen(jjtree) termList */
  ASTtermList jjtn000 = new ASTtermList(JJTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode t;}{/*@bgen(jjtree) termList */
  try {
/*@egen*/  t = term()  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;  }  (    < COMMA > term()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token rel()       :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }| t = < GT >  {    return t;  }| t = < GTEQ >  {    return t;  }| t = < SM >  {    return t;  }| t = < SMEQ >  {    return t;  }| t = < EQR >  {    return t;  }}Token eqrel()       :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }}Pair predSymbol() :
{/*@bgen(jjtree) predSymbol */
  ASTpredSymbol jjtn000 = new ASTpredSymbol(JJTPREDSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t, poundSign = null;
}
{/*@bgen(jjtree) predSymbol */
  try {
/*@egen*/
  t = < KIDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if(t.image.indexOf("K$")!=-1)
    {
        jjtn000.subj = 1;
        if(t.image.startsWith("not"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K$")+2).trim();
    }

    if(t.image.indexOf("M$")!=-1)
    {
        jjtn000.subj = 2;
        if(t.image.startsWith("not"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M$")+2).trim();
    }

    
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, false);
  }

| t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
     
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, false);
  }

 
|  LOOKAHEAD(2) [ poundSign = < POUND_SIGN > ] t = < KIDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if(t.image.indexOf("K$")!=-1)
    {
        if(poundSign!=null)
        {
             throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
        }
        jjtn000.subj = 1;
        if(t.image.startsWith("not"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K$")+2).trim();
    }

    if(t.image.indexOf("M$")!=-1)
    {
       if(poundSign!=null)
        {
             throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
        }
        jjtn000.subj = 2;
        if(t.image.startsWith("not"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M$")+2).trim();
    }
    
    if (poundSign != null)
    {
      jjtn000.setPoundSign(true);
      if (inHead)
      {
        throw new ParseException("sort name " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
      }
      String sort = "#" + t.image.substring(0, t.image.length() - 1);
      if (!predicateArgumentSorts.containsKey(sort))
      {
        throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
      }
      else
      {
        jjtn000.setTranslatedImage(predicateArgumentSorts.get(sort).get(0));
        t.image = poundSign.image + t.image;
      }
    }
    jjtn000.image = t.image.substring(0, t.image.length() - 1);
    if (sortNameToExpression.containsKey(jjtn000.image))
    {
      generatingSorts.add(jjtn000.image);
    }
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, true);
  }

  | [ poundSign = < POUND_SIGN > ] t = < IDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if(t.image.indexOf("K$")!=-1)
    {
        if(poundSign!=null)
        {
             throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
        }
        jjtn000.subj = 1;
        if(t.image.startsWith("not"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K$")+2).trim();
    }

    if(t.image.indexOf("M$")!=-1)
    {
       if(poundSign!=null)
        {
             throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
        }
        jjtn000.subj = 2;
        if(t.image.startsWith("not"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M$")+2).trim();
    }
    
    if (poundSign != null)
    {
      jjtn000.setPoundSign(true);
      if (inHead)
      {
        throw new ParseException("sort name " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
      }
      String sort = "#" + t.image.substring(0, t.image.length() - 1);
      if (!predicateArgumentSorts.containsKey(sort))
      {
        throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
      }
      else
      {
        jjtn000.setTranslatedImage(predicateArgumentSorts.get(sort).get(0));
        t.image = poundSign.image + t.image;
      }
    }
    jjtn000.image = t.image.substring(0, t.image.length() - 1);
    if (sortNameToExpression.containsKey(jjtn000.image))
    {
      generatingSorts.add(jjtn000.image);
    }
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, true);
  }
  
| t = < NEGATIVE_ATOM_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if(t.image.indexOf("K$")!=-1)
    {
        jjtn000.subj = 1;
        if(t.image.startsWith("not"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K$")+2).trim();
    }

    if(t.image.indexOf("M$")!=-1)
    {
        jjtn000.subj = 2;
        if(t.image.startsWith("-"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M$")+2).trim();
    }
    jjtn000.negative = true;
    jjtn000.image = t.image.substring(1, t.image.length() - 1);
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, true);
  }
| t = < NEGATIVE_ATOM >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if(t.image.indexOf("K$")!=-1)
    {
        jjtn000.subj = 1;
        if(t.image.startsWith("not"))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K$")+2).trim();
    }

    if(t.image.indexOf("M$")!=-1)
    {
        jjtn000.subj = 2;
        if(t.image.startsWith("not "))
        {
          jjtn000.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M$")+2).trim();
    }
    jjtn000.negative = true;
    jjtn000.image = t.image.substring(1, t.image.length());
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, false);
  }
| t = < NEGATIVE_SORT_ATOM_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setPoundSign(true);
    if (inHead)
    {
      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    String sort = t.image.substring(1, t.image.length() - 1);
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    else
    {
      jjtn000.setTranslatedImage(predicateArgumentSorts.get(sort).get(0));
      t.image = "#" + t.image.substring(1, t.image.length());
      ;
    }
    jjtn000.negative = true;
    jjtn000.image = t.image.substring(0, t.image.length() - 1);
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, true);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void atom() :{/*@bgen(jjtree) atom */
  ASTatom jjtn000 = new ASTatom(JJTATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1;}{/*@bgen(jjtree) atom */
  try {
/*@egen*/  LOOKAHEAD([ arithmeticTerm() rel() ] aggregateFunction())  aggregate()| LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() t1 = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() t1 = rel() var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(var() rel() symbolicTerm())  var() t1 = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() t1 = eqrel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() t1 = eqrel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() t1 = rel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| extendedNonRelAtom()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregate() :{/*@bgen(jjtree) aggregate */
  ASTaggregate jjtn000 = new ASTaggregate(JJTAGGREGATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1 = null, t2 = null;  jjtn000.image = "";}{/*@bgen(jjtree) aggregate */
  try {
/*@egen*/  [ arithmeticTerm() t1 = rel() ] aggregateFunction() aggregateElements() < CB > [ t2 = rel() arithmeticTerm() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (t1 != null)    {      jjtn000.image += "L" + t1.image;    }    if (t2 != null)    {      jjtn000.image += "R" + t2.image;    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateElements() :{/*@bgen(jjtree) aggregateElements */
  ASTaggregateElements jjtn000 = new ASTaggregateElements(JJTAGGREGATEELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) aggregateElements */
  try {
/*@egen*/  aggregateElement()  (    < SEMICOLON > aggregateElement()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateElement() :{/*@bgen(jjtree) aggregateElement */
  ASTaggregateElement jjtn000 = new ASTaggregateElement(JJTAGGREGATEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) aggregateElement */
  try {
/*@egen*/  (    LOOKAHEAD(2)    n = nonRelAtom()  | n = arithmeticTerm()  )  (    < COMMA >    (      LOOKAHEAD(2)      nonRelAtom()    | arithmeticTerm()    )  )*  [ < COLON > extendedSimpleAtomList() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateFunction() :{/*@bgen(jjtree) aggregateFunction */
  ASTaggregateFunction jjtn000 = new ASTaggregateFunction(JJTAGGREGATEFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) aggregateFunction */
  try {
/*@egen*/  t = < AGGREGATE_COUNT_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| t = < AGGREGATE_MAX_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| t = < AGGREGATE_MIN_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| t = < AGGREGATE_SUM_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void atomSequence() :{/*@bgen(jjtree) atomSequence */
  ASTatomSequence jjtn000 = new ASTatomSequence(JJTATOMSEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) atomSequence */
  try {
/*@egen*/  atom()  (    < COMMA > atom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void directives(ArrayList < String > directives)       :{}{  (    directive(directives)  )*  {    addBuiltInSorts();  }}void directive(ArrayList < String > directives)       :{  Token t, t1, t2, t3, t4;}{  t = < MAXINTDIRECTIVE > t1 = < EQ > t2 = < POSITIVE_INTEGER > t3 = < DOT >  {
    Integer value = Integer.parseInt(t2.image);    BuiltIn.setMaxInt(value);  }| t = < CONSTDIRECTIVE > t1 = < IDENTIFIER > t2 = < EQ > t3 = number() t4 = < DOT >  {    directives.add(t.image + " " + t1.image + t2.image + t3.image + t4.image);    constantsMapping.put(t1.image, Long.parseLong(t3.image));  }}
