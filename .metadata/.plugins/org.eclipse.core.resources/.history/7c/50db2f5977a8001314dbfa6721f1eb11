//TODO: change extendedNonRelAtom to extendedAtom.
options{  BUILD_PARSER = true;  STATIC = false;  OUTPUT_DIRECTORY = "/home/iensen/elps/ElpsTranslator/parser";  MULTI = true;}PARSER_BEGIN(ElpsTranslator)package parser;import java.io.*;import sorts.*;import java.util.HashMap;import java.util.ArrayList;import java.util.List;import java.util.HashSet;import java.util.Scanner;import java.util.Arrays;import java.util.Set;import translating.Translator;import typechecking.TypeChecker;import translating.InstanceGenerator;import configuration.ASPSolver;import externaltools.ClingoSolver;import externaltools.DLVSolver;import externaltools.ExternalSolver;import configuration.Settings;class Pair{  SimpleNode first;  boolean second;  public Pair(SimpleNode first, boolean second)  {    this.first = first;    this.second = second;  }}@ SuppressWarnings("all") public class ElpsTranslator{  // mapping from sort names to sort expressions assigned to the sorts
  public HashMap < String, ASTsortExpression > sortNameToExpression;  // mapping from predicate names to a list of names of sorts describing
  // arguments
  public HashMap < String, ArrayList < String >> predicateArgumentSorts;  // labels of cr-rules
  public HashSet < String > crRuleLabels;  //sort occurred explicitly in the program
  public HashSet < String > generatingSorts;  // mapping from constant names to their values.
  public HashMap < String, Long > constantsMapping;  // warnings found during the translation
  private ArrayList < String > warnings;  // set of all terms occurring in curly brackets and their subterms
  public HashSet < String > curlyBracketTerms;  // set of all defined record names:
  public HashSet < String > definedRecordNames;  boolean inHead = false;
  int anonSortId = 0;  /**
  * Remove from args all 
  */  private static HashSet < String > fetchOptions(String [] args)  {    HashSet < String > options = new HashSet < String > ();    for (int i = 0; i < args.length; i++)    {      if (args [i].startsWith("--"))      {        options.add(args [i]);        args = ArrayUtils.removeNthElement(args, i);        i--;      }    }    return options;  }public static String createOutputFile(String inputFile)
{
    return inputFile+".elp";
}
  public static void main(String [] args)
  {
    System.err.println("ELPS V1.02");
    if(args.length<1)
    {
      System.err.println("a path to an ELPS program must be the only argument");
      return;
    }
    String inputFile = args[0];
    String outputFile = createOutputFile(inputFile);
    Writer out = null;
    if (new File(outputFile).exists() && !new File(outputFile).isDirectory())
      {
        System.err.println("the output file already exists , do you want to overwrite it? y/n:");
        char rep;
        try
        {
          InputStreamReader converter = new InputStreamReader(System.in);
          BufferedReader in = new BufferedReader(converter);
          rep =in.readLine().charAt(0);
        }
        catch (IOException e)
        {
          e.printStackTrace();
          return;
        }
        if (rep != 'y' && rep != 'Y')
        {
          return;
        }
      }
      try
      {
        out = new FileWriter(outputFile);
      }
    catch (IOException e)
    {
       e.printStackTrace();
    }
    
    TypeChecker tc = null;
    StringBuilder translatedProgram = new StringBuilder();
    Reader sr = null;
     try
     {
        sr = new FileReader(inputFile);
     }
      catch (FileNotFoundException fileException)
      {
          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());
          return;
      }
      
      ElpsTranslator p = new ElpsTranslator(sr);
      try
      {
        
      SimpleNode e = p.program();
      //process regular expression
      InstanceGenerator gen = new InstanceGenerator(p.sortNameToExpression);
      tc = new TypeChecker(p.sortNameToExpression, p.predicateArgumentSorts, p.constantsMapping, p.curlyBracketTerms, p.definedRecordNames, gen);
      Translator tr = new Translator(out, p, gen, false, false);
      // do typechecking of rules in the first file
      String fileName=getShortFileName(inputFile);
      tr.setInputFileName(fileName);
      tc.setInputFileName(fileName);
            
      if(e.jjtGetNumChildren() >2)//if program is not empty
      {
        tc.checkRules((ASTprogramRules) e.jjtGetChild(2));
        translatedProgram.append(tr.translateProgram((ASTprogram) e, p.generatingSorts, true));
      }
      tr.writeTranslatedProgram();
    }
    catch (ParseException pe)
    {
      System.err.println(pe.getMessage());
      return;
    }
 
    System.err.println("program translated");
  }

   private boolean isInteger(String s)  {
    if(s.length()< 1)
              return false;    if (s.length() == 1 && s.charAt(0) == '0') return true;    if (s.charAt(0) == '0') return false;    for (int i = 0; i < s.length(); i++)    {      if (!Character.isDigit(s.charAt(i))) return false;    }    return true;  }  /**
  * @return absolute path.
  */  private static String getShortFileName(String fullPath)  {    File file = new File(fullPath);    return file.getName();  }  static final String newLine = System.getProperty("line.separator");  /**
  * Output help message
  */  private static void show_usage()  {    System.err.println("usage: elps filename ");  }  /**
  * Add built-in sorts to sort expressions
  */  public void addBuiltInSorts()  {    HashMap < String, ASTsortExpression > builtInSorts = BuiltIn.getBuiltInSorts();    for (String sortName : builtInSorts.keySet())    {      sortNameToExpression.put(sortName, builtInSorts.get(sortName));    }  }  /**
  * Add warning to set of warnings
  */  public void addWarning(String warning)  {    warnings.add(warning);  }  public ArrayList < String > getWarnings()  {    return warnings;  }}PARSER_END(ElpsTranslator)< DEFAULT, IN_PROGRAM_RULES >TOKEN :{  < MAXINTDIRECTIVE : "#maxint" >| < CONSTDIRECTIVE : "#const" >| < SORTDEFKEYWORD : "sorts" ([ "\r", "\t", " ", "\n" ])+ >| < PREDDEFKEYWORD : "predicates" ([ "\r", "\t", " ", "\n" ])+ >| < PROGRULDEFKEYWORD : "rules" ([ "\r", "\t", " ", "\n" ])+ > : IN_PROGRAM_RULES| < NOT : "not" ([ "\t", "\r", " " ])+ >| < NOTOP : "not" ([ "\t", "\r", " " ])* "(" >| < OR : "or" >| < AND : "and" >| < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
| < KIDENTIFIER : (("not " ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )? [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >| < VARIABLE :    (      [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])*    | "_"    ) >| < NONZERODIGIT : [ "1"-"9" ] >| < POSITIVE_INTEGER :    < NONZERODIGIT >    (      < ZERO >    | < NONZERODIGIT >    )* >| < ZERO : "0" >| < PLUS : "+" >| < MULT : "*" >| < DIV : "/" >| < EQ : "=" >| < EQR : "==" >| < NOTEQ : "!=" >| < GT : ">" >| < GTEQ : ">=" >| < SM : "<" >| < SMEQ : "<=" >| < OP : "(" >| < CP : ")" >| < OB : "{" >| < CB : "}" >| < ORRSEP : ":-" >| < CRRSEP : ":+" >| < WEAKSEP : ":~" >| < COMMA : "," >| < DOT : "." >| < COLON : ":" >| < SEMICOLON : ";" >| < COMPLEMENT : "~" >| < HEAD_OR : "|" >| < AGGREGATE_COUNT_OB : "#count"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_SUM_OB : "#sum"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_MIN_OB : "#min"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_MAX_OB : "#max"([ "\t", "\r", "\n"," " ])* "{" >| < OSB : "[" >| < OCB : "]" >| < POUND_SIGN : "#" >}< IN_PROGRAM_RULES >TOKEN :
{
 < IDENTIFIER_WITH_OP : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )? [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >
|< KIDENTIFIER_WITH_OP : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )? [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >
| < NEGATIVE_ATOM_WITH_OP : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )?"-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >
| < NEGATIVE_SORT_ATOM_WITH_OP : "-#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n" ])* "(" >
| < NEGATIVE_ATOM : (("not" ([ "\r", "\t", " ", "\n" ])+)?("K$"|"M$")([ "\r", "\t", " ", "\n" ])* )?"-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >SKIP :{  < SINGLE_LINE_COMMENT :    "%" (~[ "\n", "\r" ])*    (      "\r"    | "\n"    | "\r\n"    )? >| < SPACE : ([ "\n", "\r", "\t", " " ])+ >}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >TOKEN :{  < MINUS : "-" >}SimpleNode program() :{  sortNameToExpression = new HashMap < String, ASTsortExpression > ();  predicateArgumentSorts = new HashMap < String, ArrayList < String >> ();  crRuleLabels = new HashSet < String > ();  generatingSorts = new HashSet < String > ();  constantsMapping = new HashMap < String, Long > ();  warnings = new ArrayList < String > ();  curlyBracketTerms = new HashSet < String > ();  definedRecordNames = new HashSet < String > ();}{  directives(jjtThis.directives) sortDefinitions() predicateDeclarations() programRules() < EOF >  {    return jjtThis;  } | < EOF >  {
    return jjtThis;  }
  }void sortDefinitions() :{}{  (    < SORTDEFKEYWORD >    (      sortDefinition()    )*  )|  {}}void sortDefinition() :{  Token t;  SimpleNode n;}{  < POUND_SIGN > t = < IDENTIFIER > < EQ > n = sortExpression() < DOT >  {    if (sortNameToExpression.containsKey(t.image))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was already defined");    }    for (String builtInSortName : BuiltIn.sortNames)    {      if (t.image.equals(builtInSortName))      {        throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " is built-in and cannot be redefined");      }    }    if (EmptySortChecker.isEmpty((ASTsortExpression) n, sortNameToExpression))    {      throw new ParseException("sort " + t.image + " defined at line " + t.beginLine + " column " + t.beginColumn + " is empty");    }    sortNameToExpression.put(t.image, (ASTsortExpression) n);  }}SimpleNode sortExpression() :{  SimpleNode n;  String s;}{
  LOOKAHEAD(2)  n = setExpression()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }| LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })  n = numericRange()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }| LOOKAHEAD(identifierRange())  n = identifierRange()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }| n = concatenation()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode setExpression() :{  SimpleNode n;}{  n = additiveSetExpression()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode multiplicativeSetExpression() :{  SimpleNode n;}{  n = unarySetExpression()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  (    < MULT > unarySetExpression()  )*  {    return jjtThis;  }}SimpleNode additiveSetExpression() :{  jjtThis.image = "+";  SimpleNode n;}{  n = multiplicativeSetExpression()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  (    (      "+"      {        jjtThis.image += "+";      }    | "-"      {        jjtThis.image += "-";      }    )    multiplicativeSetExpression()  )*  {    return jjtThis;  }}SimpleNode sortName() :{  Token t;}{  t = < IDENTIFIER >  {    if (!sortNameToExpression.containsKey(t.image))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");    }    else    {      jjtThis.image = t.image;      jjtThis.beginLine = t.beginLine;      jjtThis.beginColumn = t.beginColumn;    }    return jjtThis;  }}SimpleNode unarySetExpression() :{  Token t;  SimpleNode n;}{  t = < POUND_SIGN > sortName()  {    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }| n = curlyBrackets()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }| t = < OP > setExpression() < CP >  {    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }

  | n = functionalSymbol() 
  {
    if (!FunctionalSymbolChecker.checkFunctionalSymbolSorts((ASTfunctionalSymbol) n, sortNameToExpression))
    {
      throw new ParseException("the definition of record " + n.image + " at line " + n.beginLine + " column " + n.beginColumn + " has a condition which involves " + "checking less/greater relations on elements of non-basic sorts");
    }
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }}SimpleNode curlyBrackets() :{  Token t;  SimpleNode child;}{  t = < OB > child = constantTermList() < CB >  {    CurlyBrackets.retrieveAllTerms((ASTconstantTermList) child, curlyBracketTerms);    CurlyBrackets.retrieveAllFunctionalSymbols(jjtThis, definedRecordNames);    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }}void concatenationTermList() #constantTermList :{}{  concatenationTerm()  (    < COMMA > concatenationTerm()  )*}SimpleNode constantTermList() :{}{  constantTerm()  (    < COMMA > constantTerm()  )*  {    return jjtThis;  }}void constantTerm():{  Token t1, t2, t3;  String s;}{  LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })  t1 = number()  {    jjtThis.image = t1.image;  }| LOOKAHEAD(2)  t1 = < IDENTIFIER > t3 = < OP > constantTermList() t2 = < CP >  {    jjtThis.image = t1.image + t3.image + " " + t2.image;  }| t1 = < IDENTIFIER >  {    jjtThis.image = t1.image;  }}void concatenationTerm() #constantTerm :{  Token t1;}{  LOOKAHEAD({ constantsMapping.containsKey(getToken(1).image) })  t1 = number()  {    jjtThis.image = t1.image;  }| t1 = < IDENTIFIER >  {    jjtThis.image = t1.image;  }}SimpleNode condition(HashMap < String, Integer > varMap) :{  Token t, t1, t2;}{  orCondition(varMap)  {    return jjtThis;  }}void orCondition(HashMap < String, Integer > varMap) :{}{  andCondition(varMap)  (    < OR > andCondition(varMap)  )*}void andCondition(HashMap < String, Integer > varMap) :{}{  unaryCondition(varMap)  (    < AND > unaryCondition(varMap)  )*}void unaryCondition(HashMap < String, Integer > varMap) :{  Token t, t3, t4;}{  t3 = var()  {    jjtThis.image = varMap.get(t3.image).toString();  }  t = rel()  {    jjtThis.image += " " + t.image;  }  t4 = var()  {    jjtThis.image += " " + varMap.get(t4.image).toString();  }| < OP > condition(varMap) < CP >| t = < NOTOP > condition(varMap) < CP >  {    jjtThis.image = t.image;  }}SimpleNode functionalSymbol() :{  Token t1, t2, t3;  Token from, to;  HashMap < String, Integer > map;  HashSet < Integer > BasicSorts;  SimpleNode c = null;}{  t1 = < IDENTIFIER > t3 = < OP >  {}  map = specialSortExpressionList() t2 = < CP > [ < COLON > c = condition(map) ]  {    definedRecordNames.add(t1.image);    jjtThis.beginLine = t1.beginLine;    jjtThis.beginColumn = t1.beginColumn;    jjtThis.image = t1.image + t3.image + t2.image;    return jjtThis;  }}Token specialSortExpression() #void :{  Token sortToken,t = null;}{  < POUND_SIGN > sortName() [ < OP > t = < VARIABLE > < CP > ]  {    return t;  }}HashMap < String, Integer > specialSortExpressionList() #sortExpressionList :{  HashMap < String, Integer > variableMapping = new HashMap < String, Integer > ();  int agr = 0;  Token t;}{  t = specialSortExpression()  {    if (t != null)    {      if (variableMapping.containsKey(t.image))      {        throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");      }      variableMapping.put(t.image, agr);    }    agr++;  }  (    < COMMA > t = specialSortExpression()    {      if (t != null)      {        if (variableMapping.containsKey(t.image))        {          throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");        }        variableMapping.put(t.image, agr);      }      agr++;    }  )*  {    return variableMapping;  }}SimpleNode concatenation() :{}{  (    < OSB > basicSort() < OCB >  )+  {    return jjtThis;  }}void basicSort() :{  SimpleNode se;  Token t;  String s;}{  LOOKAHEAD({ (getToken(1) != null && (s = getToken(1).image) != null) && (constantsMapping.containsKey(s) || isInteger(s)) })  numericRange()| LOOKAHEAD(identifierRange())  identifierRange()| t = < POUND_SIGN > se = sortName()  {    if (!sortNameToExpression.containsKey(se.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");    }    ASTsortExpression ex = sortNameToExpression.get(se.image);    if (!BasicSortChecker.isBasic(ex, sortNameToExpression))    {      throw new ParseException("ERROR: Sort '" + se.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is not a basic sort");    }  }| concatenationTermList()}SimpleNode identifierRange() :{  Token t1, t2;}{  t1 = < IDENTIFIER > < DOT > < DOT > t2 = < IDENTIFIER >  {    int errorLine = t1.beginLine;    int errorColumn = t1.beginColumn;    if (t1.image.length() > t2.image.length())    {      throw new ParseException("ERROR: the length of the first identifier in identifier range should be smaller or equal to the length of the second one " + "at line " + errorLine + ", column " + errorColumn);    }    if (t1.image.compareTo(t2.image) > 0)    {      throw new ParseException("ERROR: the first identifier in identifier range should be lexicographically smaller or equal to  the second one " + "at line " + errorLine + ", column " + errorColumn);    }    jjtThis.image = t1.image + " " + t2.image;
    return jjtThis;  }}SimpleNode numericRange() :{  Token from, to;}{  from = number()  {    jjtThis.beginLine = from.beginLine;    jjtThis.beginColumn = from.beginColumn;  }  < DOT > < DOT > to = number()  {    int fromI = 0;    int toI = 0;    try    {      fromI = Integer.parseInt(from.image);      toI = Integer.parseInt(to.image);    }    catch (NumberFormatException ex)    {}    if (fromI > toI)    {      throw new ParseException("ERROR: the first number in numeric  range should be smaller or equal to  the second one " + "at line " + to.beginLine + ", column " + to.beginColumn);    }    jjtThis.image = from.image + " " + to.image;    return jjtThis;  }}Token number() #void :{  Token t;}{  t = < POSITIVE_INTEGER >  {
    int integer = Integer.parseInt(t.image);
	if(integer >  BuiltIn.getMaxInt() )	{	    throw new ParseException("ERROR: Integer '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is out of range");
    }    return t;  }| t = < ZERO >  {    return t;  }| t = < NONZERODIGIT >  {    return t;  }| t = < IDENTIFIER >  {    if (!constantsMapping.containsKey(t.image))    {      throw new ParseException("ERROR: Constant '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " was not defined");      //return t;
    }    else    {      t.image = constantsMapping.get(t.image).toString();      return t;    }  }}void predicateDeclarations() :{}{  < PREDDEFKEYWORD >  (    predicateDeclaration()  )*  {    HashSet < String > usedPredicateNames = new HashSet < String > ();    usedPredicateNames.addAll(predicateArgumentSorts.keySet());
    HashMap<String,String > sortRenaming=new HashMap<String,String >();    for (String sortName : sortNameToExpression.keySet())    {      predicateArgumentSorts.put("#" + sortName, new ArrayList < String > ());      String nameCandidate = sortName;      while (usedPredicateNames.contains(nameCandidate))      {        nameCandidate += "_";      }      usedPredicateNames.add(nameCandidate);      predicateArgumentSorts.get("#" + sortName).add(nameCandidate);
      if(!sortName.equals(nameCandidate))      {
        //update all sort names from predicate lists:
        sortRenaming.put(sortName,nameCandidate);
        for(String predicateName:predicateArgumentSorts.keySet())        {           ArrayList<String > arguments= predicateArgumentSorts.get(predicateName);
           for(int i=0;i<arguments.size();i++)           {               if(arguments.get(i).equals(sortName))               {
                 arguments.set(i,nameCandidate);               }
           }
        }

        // update all sort names in functional symbol definitions!!!

        for(String sortName1:sortNameToExpression.keySet())        {
          ASTsortExpression se= sortNameToExpression.get(sortName1);
          SimpleNode child = (SimpleNode)se.jjtGetChild(0);
          if(child.getId() == ElpsTranslatorTreeConstants.JJTSETEXPRESSION)          {
            SimpleNode additiveSetExpr = (SimpleNode) child.jjtGetChild(0);
            for(int i=0;i<additiveSetExpr.jjtGetNumChildren();i++)            {
              SimpleNode multiplicativeSetExpr = (SimpleNode) additiveSetExpr.jjtGetChild(i);
              for(int j=0;j<multiplicativeSetExpr.jjtGetNumChildren();j++)              {                   SimpleNode unarySortExpr = (SimpleNode) multiplicativeSetExpr.jjtGetChild(j);
                   child = (SimpleNode)unarySortExpr.jjtGetChild(0);
                   if(child.getId() == ElpsTranslatorTreeConstants.JJTFUNCTIONALSYMBOL)
                   {
                       ASTsortExpressionList sortNameList = (ASTsortExpressionList)child.jjtGetChild(0);
                       for(int k=0;k<sortNameList.jjtGetNumChildren();k++)
                       {           
                            ASTsortName oldSortName = (ASTsortName)sortNameList.jjtGetChild(k);
                            if(oldSortName.image.equals(sortName))                            {
                                oldSortName.image = sortRenaming.get(oldSortName.image);                            }                          
                       }
                  }
              }            }              }        }      }    }
    for(String sortName:sortRenaming.keySet())    {
        sortNameToExpression.put(sortRenaming.get(sortName),sortNameToExpression.get(sortName));
        sortNameToExpression.remove(sortName);    }  }}void predicateDeclaration() :{  Token t;  ArrayList < String > arguments = new ArrayList < String > ();}{  t = < IDENTIFIER >  {    if (predicateArgumentSorts.containsKey(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " was already declared");    }    if (BuiltInPredicates.predicateNamesSet.contains(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " is a built-in predicate");    }  }  < OP >  (    arguments = identifierList()  )?  {    predicateArgumentSorts.put(t.image, arguments);  }  < CP > < DOT >}ArrayList < String > identifierList() :{  ArrayList < String > result = new ArrayList < String > ();  Token t;}{
    (    < POUND_SIGN > t = < IDENTIFIER >  {    if (!sortNameToExpression.containsKey(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");    }    result.add(t.image);  }  (    < COMMA > < POUND_SIGN > t = < IDENTIFIER >    {
     if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");
    }      result.add(t.image);    }  )*)  {    return result;  }}SimpleNode programRules() :{}{  < PROGRULDEFKEYWORD >  (    programRule()  )*  {    return jjtThis;  }}SimpleNode programRule() :{  Token t;  SimpleNode n;  inHead = true;}{  LOOKAHEAD(2)  t = label()  {    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    jjtThis.setLabel(t.image);    if (crRuleLabels.contains(t.image))    {      throw new ParseException("cr-rule label " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " occures more then once");    }    else    {      crRuleLabels.add(t.image);    }  }  n = unlabeledProgramCrRule()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }| n = unlabeledProgramRule()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode unlabeledProgramRule() :{  Pair n;  SimpleNode n2;  Token from, to, sep;}{  LOOKAHEAD(predSymbol() number() < DOT >)  n = predSymbol() from = number() < DOT > < DOT > to = number() < CP > < DOT > //can be body here after safety fix!
  {    jjtThis.beginLine = n.first.beginLine;    jjtThis.beginColumn = n.first.beginColumn;    jjtThis.image = n.first.image + " " + from.image + " " + to.image;    inHead = false;    return jjtThis;  }| n2 = head()  {    inHead = false;  }  sep = exBody()  {    jjtThis.image = sep.image;    jjtThis.beginLine = n2.beginLine;    jjtThis.beginColumn = n2.beginColumn;    return jjtThis;  }| sep = < ORRSEP >  {    inHead = false;    jjtThis.image = sep.image;    jjtThis.beginLine = sep.beginLine;    jjtThis.beginColumn = sep.beginColumn;  }  body() < DOT >  {    return jjtThis;  }| sep = < CRRSEP >  {    inHead = false;    jjtThis.beginLine = sep.beginLine;    jjtThis.beginColumn = sep.beginColumn;    jjtThis.image = sep.image;  }  body() < DOT >  {    return jjtThis;  }| sep = < WEAKSEP >  {    inHead = false;    jjtThis.beginLine = sep.beginLine;    jjtThis.beginColumn = sep.beginColumn;    jjtThis.image = sep.image;  }  body() < DOT > [ constraintParams() ]  {    return jjtThis;  }}void constraintParams() :{  Token t0;  Token t1 = null, t2 = null, t3 = null, t4 = null, t5 = null;  jjtThis.image = "";}{  t0 = < OSB >  [    (      t1 = var()    | t2 = number()    )  ]  t5 = < COLON >  [    (      t3 = var()    | t4 = number()    )  ]  < OCB >  {    if (t1 == null && t2 == null && t3 == null && t4 == null)    {      throw new ParseException("line " + t0.beginLine + ", column " + t0.beginColumn + ": weak constraint paramethers cannot both be empty");    }    if (t2 != null)    {      jjtThis.image += t2.image;    }    else if (t1 != null)    {      jjtThis.image += "V";    }    jjtThis.image += t5.image;    if (t4 != null)    {      jjtThis.image += t4.image;    }    else if (t3 != null)    {      jjtThis.image += "V";    }  }}SimpleNode unlabeledProgramCrRule() :{  SimpleNode n;  Token t;}{  n = head() t = exCrBody()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    jjtThis.image = t.image;    return jjtThis;  }| t = < CRRSEP > body() < DOT >  {    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    jjtThis.image = t.image;    return jjtThis;  }}Token label() #void :{  Token t;}{  t = < IDENTIFIER > < COLON >  {    return t;  }}Token exBody() #void :{  Token t;}{  t = exStandartBody()  {    return t;  }| t = exCrBody()  {    return t;  }}Token exStandartBody() #void :{  Token t;}{  t = < ORRSEP > body() < DOT >  {    return t;  }| t = < DOT >  {    return new Token(ElpsTranslatorConstants.ORRSEP, ":-");  }}Token exCrBody() #void :{  Token t;}{  t = < CRRSEP > crBodyWithoutSep()  {    return t;  }}void crBodyWithoutSep() #void :{}{  < DOT >| body() < DOT >}SimpleNode head() :{  SimpleNode n;}{  LOOKAHEAD(2)  n = choice_rule()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }| n = disjunction()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode disjunction() :{  SimpleNode n;}{  n = nonRelAtom()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  (    < HEAD_OR > nonRelAtom()  )*  {    return jjtThis;  }}SimpleNode choice_rule() :{  SimpleNode n1 = null;  Token t;}{  [    n1 = arithmeticTerm()    [      t = rel()      {        jjtThis.image = "L" + t.image;      }    ]  ]  t = < OB > choice_elements() < CB >  [    [      t = rel()      {        jjtThis.image += " R" + t.image;      }    ]    arithmeticTerm()  ]  {    if (n1 != null)    {      jjtThis.beginLine = n1.beginLine;      jjtThis.beginColumn = n1.beginColumn;    }    else    {      jjtThis.beginLine = t.beginLine;      jjtThis.beginColumn = t.beginColumn;    }    if (Settings.getSingletonInstance().getSolver() != ASPSolver.Clingo)     throw new ParseException("line " + jjtThis.beginLine + ", column " + jjtThis.beginColumn + ": choice rules are not supported in DLV");    return jjtThis;  }}void choice_elements() :{}{  choice_element()  (    < SEMICOLON > choice_element()  )*}void choice_element() :{  SimpleNode n;}{  n = nonRelAtom() [ < COLON > extendedSimpleAtomList() ]  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }}void extendedSimpleAtomList() :{}{  simpleAtom()  (    < COMMA > simpleAtom()  )*}void body() :{}{  atom()  (    < COMMA > atom()  )*}Token var() :{  Token t;}{  t = < VARIABLE >  {    jjtThis.image = t.image;    jjtThis.setOriginalImage(t.image);    return t;  }}SimpleNode nonRelAtom():{  SimpleNode tList = null;  Pair n;}{  n = predSymbol()  {    jjtThis.beginLine = n.first.beginLine;    jjtThis.beginColumn = n.first.beginColumn;
    String disallowedPrefixes[] = {"k_","m_","k_0","m_0","k1_0","k0_0",
				                   "k1_","k0_","m1_0","m1_","m0_0","m0_"};
    for(String prefix: disallowedPrefixes)    {        if(n.first.image.startsWith(prefix))        {
             throw new ParseException("ERROR: predicate names starting from "+ prefix +" are not allowed; line " + n.first.beginLine + " column " + n.first.beginColumn);        }
    }

    ASTpredSymbol predS1 = (ASTpredSymbol) n.first;
    if(predS1.subj!=0)
    {
        throw new ParseException("ERROR: subjective literals are only allowed in the bodies of rules; line " + n.first.beginLine + " column " + n.first.beginColumn);
    }  }  [    tList = termList()    {      if (!n.second && tList != null)      {        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);      }    }    < CP >  ]  {    ASTpredSymbol predS = (ASTpredSymbol) n.first;    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1))    {      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");    }    return jjtThis;  }}void simpleAtom() :{  SimpleNode n;  Token t;}{  LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() t = rel() symbolicTerm()  {    jjtThis.image = t.image;  }| LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() t = rel() var()  {    jjtThis.image = t.image;  }| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() t = rel() arithmeticTerm()  {    jjtThis.image = t.image;  }| LOOKAHEAD(var() rel() symbolicTerm())  var() t = rel() symbolicTerm()  {    jjtThis.image = t.image;  }| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() t = eqrel() symbolicTerm()  {    jjtThis.image = t.image;  }| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() t = eqrel() arithmeticTerm()  {    jjtThis.image = t.image;  }| n = extendedNonRelAtom()  {    jjtThis.image = n.image;  }}SimpleNode extendedNonRelAtom() :{  Token t = null;  jjtThis.image = "";  SimpleNode tList = null;  Pair n;}{  [    t = < NOT >    {      jjtThis.image = t.image;    }  ]  n = predSymbol(){
    ASTpredSymbol predS1 = (ASTpredSymbol) n.first;
    if(n.first.image.startsWith("k_") || n.first.image.startsWith("m_"))
    {
        throw new ParseException("ERROR: predicate names starting from k_ or m_ are not allowed; line " + n.first.beginLine + " column " + n.first.beginColumn);
    }

    if(t!=null && (predS1.subj!=0))
    {
        throw new ParseException("ERROR: not is not allowed before subjective literals " + n.first.beginLine + " column " + n.first.beginColumn);
    }
  }
    [    tList = termList()    {      if (!n.second && tList != null)      {        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);      }    }    < CP >  ]  {    ASTpredSymbol predS = (ASTpredSymbol) n.first;    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1))    {      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");    }    return jjtThis;  }}SimpleNode addOp() #void:{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < PLUS >  {    n.image = t.image;    return n;  }| t = < MINUS >  {    n.image = t.image;    return n;  }}SimpleNode multOp() #void :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < MULT >  {    n.image = t.image;    return n;  }| t = < DIV >  {    n.image = t.image;    return n;  }}SimpleNode arithmeticTerm() :{  SimpleNode n;}{  n = additiveArithmeticTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode atomicArithmeticTerm() :{  Token t;
 }{
  
  LOOKAHEAD({  (getToken(1) != null && getToken(1).image != null) && (constantsMapping.containsKey(getToken(1).image ) || isInteger(getToken(1).image )) })  t = number()  {    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }| t = var()  {    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }| t = < OP > arithmeticTerm() < CP >  {    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }}SimpleNode additiveArithmeticTerm() :{  SimpleNode n;  jjtThis.image = "+";}{  n = multiplicativeArithmeticTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  (    n = addOp()    {      jjtThis.image += n.image;    }    multiplicativeArithmeticTerm()  )*  {    return jjtThis;  }}SimpleNode multiplicativeArithmeticTerm() :{  SimpleNode n;  jjtThis.image = "";}{  n = atomicArithmeticTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  (    n = multOp()    {      jjtThis.image += n.image;    }    atomicArithmeticTerm()  )*  {    return jjtThis;  }}SimpleNode symbolicFunction() :{  Token t;}{  t = < IDENTIFIER_WITH_OP >  {    jjtThis.image = t.image;    jjtThis.beginColumn = t.beginColumn;    jjtThis.beginLine = t.beginLine;    return jjtThis;  }}
SimpleNode symbolicConstant() :
{
  Token t;
}
{
  t = < IDENTIFIER >
  {
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;
  }
}SimpleNode symbolicTerm() :{  SimpleNode n;}{  n = symbolicConstant()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }| n = symbolicFunction()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }  termList() < CP >  {    return jjtThis;  }}SimpleNode term() :{  SimpleNode n;  Token t;  jjtThis.image = "";}{ LOOKAHEAD(var() (< CP >| < COMMA >))  t = var()  {    //System.out.println("t.image");
    jjtThis.image = t.image;    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;    return jjtThis;  }
| 
  LOOKAHEAD(2)
  n = arithmeticTerm()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }| n = symbolicTerm()  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;    return jjtThis;  }}SimpleNode termList() :{  SimpleNode t;}{  t = term()  {    jjtThis.beginLine = t.beginLine;    jjtThis.beginColumn = t.beginColumn;  }  (    < COMMA > term()  )*  {    return jjtThis;  }}Token rel() #void :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }| t = < GT >  {    return t;  }| t = < GTEQ >  {    return t;  }| t = < SM >  {    return t;  }| t = < SMEQ >  {    return t;  }| t = < EQR >  {    return t;  }}Token eqrel() #void :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }}Pair predSymbol() :
{
  Token t, poundSign = null;
}
{
  t = < KIDENTIFIER >
  {
    if(t.image.indexOf("K$")!=-1)
    {
        jjtThis.subj = 1;
        if(t.image.startsWith("not"))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K$")+2).trim();
    }

    if(t.image.indexOf("M$")!=-1)
    {
        jjtThis.subj = 2;
        if(t.image.startsWith("not"))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M$")+2).trim();
    }

    
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, false);
  }

| t = < IDENTIFIER >
  {
     
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, false);
  }

 
|  LOOKAHEAD(2) [ poundSign = < POUND_SIGN > ] t = < KIDENTIFIER_WITH_OP >
  {
    if(t.image.indexOf("K$")!=-1)
    {
        if(poundSign!=null)
        {
             throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
        }
        jjtThis.subj = 1;
        if(t.image.startsWith("not "))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K$")+1).trim();
    }

    if(t.image.indexOf("M")!=-1)
    {
       if(poundSign!=null)
        {
             throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
        }
        jjtThis.subj = 2;
        if(t.image.startsWith("-"))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M")+1).trim();
    }
    
    if (poundSign != null)
    {
      jjtThis.setPoundSign(true);
      if (inHead)
      {
        throw new ParseException("sort name " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
      }
      String sort = "#" + t.image.substring(0, t.image.length() - 1);
      if (!predicateArgumentSorts.containsKey(sort))
      {
        throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
      }
      else
      {
        jjtThis.setTranslatedImage(predicateArgumentSorts.get(sort).get(0));
        t.image = poundSign.image + t.image;
      }
    }
    jjtThis.image = t.image.substring(0, t.image.length() - 1);
    if (sortNameToExpression.containsKey(jjtThis.image))
    {
      generatingSorts.add(jjtThis.image);
    }
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, true);
  }

  | [ poundSign = < POUND_SIGN > ] t = < IDENTIFIER_WITH_OP >
  {
    if(t.image.indexOf("K")!=-1)
    {
        if(poundSign!=null)
        {
             throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
        }
        jjtThis.subj = 1;
        if(t.image.startsWith("-"))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K")+1).trim();
    }

    if(t.image.indexOf("M")!=-1)
    {
       if(poundSign!=null)
        {
             throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
        }
        jjtThis.subj = 2;
        if(t.image.startsWith("-"))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M")+1).trim();
    }
    
    if (poundSign != null)
    {
      jjtThis.setPoundSign(true);
      if (inHead)
      {
        throw new ParseException("sort name " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
      }
      String sort = "#" + t.image.substring(0, t.image.length() - 1);
      if (!predicateArgumentSorts.containsKey(sort))
      {
        throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
      }
      else
      {
        jjtThis.setTranslatedImage(predicateArgumentSorts.get(sort).get(0));
        t.image = poundSign.image + t.image;
      }
    }
    jjtThis.image = t.image.substring(0, t.image.length() - 1);
    if (sortNameToExpression.containsKey(jjtThis.image))
    {
      generatingSorts.add(jjtThis.image);
    }
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, true);
  }
  
| t = < NEGATIVE_ATOM_WITH_OP >
  {
    if(t.image.indexOf("K")!=-1)
    {
        jjtThis.subj = 1;
        if(t.image.startsWith("-"))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K")+1).trim();
    }

    if(t.image.indexOf("M")!=-1)
    {
        jjtThis.subj = 2;
        if(t.image.startsWith("-"))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M")+1).trim();
    }
    jjtThis.negative = true;
    jjtThis.image = t.image.substring(1, t.image.length() - 1);
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, true);
  }
| t = < NEGATIVE_ATOM >
  {
    if(t.image.indexOf("K")!=-1)
    {
        jjtThis.subj = 1;
        if(t.image.startsWith("not "))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("K")+1).trim();
    }

    if(t.image.indexOf("M")!=-1)
    {
        jjtThis.subj = 2;
        if(t.image.startsWith("not "))
        {
          jjtThis.negatedSubj = true;
        }
        t.image = t.image.substring(t.image.indexOf("M")+1).trim();
    }
    jjtThis.negative = true;
    jjtThis.image = t.image.substring(1, t.image.length());
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, false);
  }
| t = < NEGATIVE_SORT_ATOM_WITH_OP >
  {
    jjtThis.setPoundSign(true);
    if (inHead)
    {
      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    String sort = t.image.substring(1, t.image.length() - 1);
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    else
    {
      jjtThis.setTranslatedImage(predicateArgumentSorts.get(sort).get(0));
      t.image = "#" + t.image.substring(1, t.image.length());
      ;
    }
    jjtThis.negative = true;
    jjtThis.image = t.image.substring(0, t.image.length() - 1);
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, true);
  }
}

void atom() :{  Token t1;}{  LOOKAHEAD([ arithmeticTerm() rel() ] aggregateFunction())  aggregate()| LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() t1 = rel() symbolicTerm()  {    jjtThis.image = t1.image;  }| LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() t1 = rel() var()  {    jjtThis.image = t1.image;  }| LOOKAHEAD(var() rel() symbolicTerm())  var() t1 = rel() symbolicTerm()  {    jjtThis.image = t1.image;  }| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() t1 = eqrel() symbolicTerm()  {    jjtThis.image = t1.image;  }| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() t1 = eqrel() arithmeticTerm()  {    jjtThis.image = t1.image;  }| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() t1 = rel() arithmeticTerm()  {    jjtThis.image = t1.image;  }| extendedNonRelAtom()}void aggregate() :{  Token t1 = null, t2 = null;  jjtThis.image = "";}{  [ arithmeticTerm() t1 = rel() ] aggregateFunction() aggregateElements() < CB > [ t2 = rel() arithmeticTerm() ]  {    if (t1 != null)    {      jjtThis.image += "L" + t1.image;    }    if (t2 != null)    {      jjtThis.image += "R" + t2.image;    }  }}void aggregateElements() :{}{  aggregateElement()  (    < SEMICOLON > aggregateElement()  )*}void aggregateElement() :{  SimpleNode n;}{  (    LOOKAHEAD(2)    n = nonRelAtom()  | n = arithmeticTerm()  )  (    < COMMA >    (      LOOKAHEAD(2)      nonRelAtom()    | arithmeticTerm()    )  )*  [ < COLON > extendedSimpleAtomList() ]  {    jjtThis.beginLine = n.beginLine;    jjtThis.beginColumn = n.beginColumn;  }}void aggregateFunction() :{  Token t;}{  t = < AGGREGATE_COUNT_OB >  {    jjtThis.image = t.image;  }| t = < AGGREGATE_MAX_OB >  {    jjtThis.image = t.image;  }| t = < AGGREGATE_MIN_OB >  {    jjtThis.image = t.image;  }| t = < AGGREGATE_SUM_OB >  {    jjtThis.image = t.image;  }}void atomSequence() :{}{  atom()  (    < COMMA > atom()  )*}void directives(ArrayList < String > directives) #void :{}{  (    directive(directives)  )*  {    addBuiltInSorts();  }}void directive(ArrayList < String > directives) #void :{  Token t, t1, t2, t3, t4;}{  t = < MAXINTDIRECTIVE > t1 = < EQ > t2 = < POSITIVE_INTEGER > t3 = < DOT >  {
    Integer value = Integer.parseInt(t2.image);    BuiltIn.setMaxInt(value);  }| t = < CONSTDIRECTIVE > t1 = < IDENTIFIER > t2 = < EQ > t3 = number() t4 = < DOT >  {    directives.add(t.image + " " + t1.image + t2.image + t3.image + t4.image);    constantsMapping.put(t1.image, Long.parseLong(t3.image));  }}
